<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body>
    <noscript>
      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>

<style>
  body{
    padding: 0;
    margin:0;
  }
</style>

<script>

var obj={
  f:{
    name:'fff',
    age:20,
    call:null
  }
}
obj.f.call=obj.f;
// try{JSON.stringify(obj)}
//   catch(e){

//    console.log(e)

// }

// Function.prototype.call2 = function(content = window) {
//     content.fn = this;
//     let args = [...arguments].slice(1);
//     let result = content.fn(...args);
//     delete content.fn;
//     return result;
// }
// let foo = {
//     value: 1
// }
// function bar(name, age) {
//     console.log(name)
//     console.log(age)
//     console.log(this.value);
// }
// bar.call2(foo, 'black', '18') // black 18 1

function create(obj){
  let F = function(){}
  F.prototype = obj
  return new F()
}


function apply2(content=window){
     content.fn = this
     let result
     if(arguments[1]){
        result = content.fn(...arguments[1])
     }else{
       result = content.fn()
     }
     delete content.fn
     return result


}
function debounce(fn,delay){
   let timer = null
   return function(){
     if(timer){
       clearInterval(timer)
     }
     timer=setTimeout(()=>{
       fn.apply(this,arguments)
     },delay)

   }


}


// Promise.resolve(1)
// .then((x)=> x + 1)
// .then((x)=> { throw new Error('My Error') })
// .catch(()=>1)
// .then((x)=>x + 1)
// .then((x)=>console.log(x))
// .catch(console.error)
/*
事件绑定函数

function on(el,type,select, fn){
   if(fn==null){
     fn = select 
     select = null
     el.addEventListener(type,fn,False)
   }
   else{
     el.addEventListener(type,(e)=>{
       target = e.traget
       if(target.matches(select)){
         fn.call(target,e)
       }
     },false)

   } 


}

*/

/*bind方法，返回一个构造函数，这个构造函数以当前调用的对象为原型，从而实现继承
原理：
1、获取参数值和当前的this
2、构造一个函数，用apply方法改变this
3、让构造函数的原型指向当前this的实例，从而实现继承
   实现方法1、Fn.prototype = object.create(that.prototype)
   2、temp = fun
      temp.prototype = that.
    Fn.protype = new temp
  

*/

let mapstate = {a:1,b:'state'}
let json = {c:[1,2],...mapstate}
//进制转换函数,实现思路
/*
用rest操作符取出需要进行操作的字符，放入新数组中保存起来
用rest操作符，结合slice方法取出最后一个参数，即位数
双层循环，第一层依次取出每个字符，第二层取出单个字符，转换成数字
        计算进位值，公式为Math.pow(n,i),n为进制，i为幂，即n^i
        将进位值与数字值相乘，加上res
返回res，即对应进位制下的值

细节：转换数字的时候，需要获取单个数字的index，计算公式为字符长度-当前进位-1，例如“02”，2的index为1，位数为0（0位），等于2-0-1


*/

function add(...args){
   let len = [...args].length
   let str = [...args].slice(0,len-1)
   let n = [...args][len-1]
   let res = 0 
   for(let s of str){
     for(let i=0;i<s.length;i++){
       res = res + Math.pow(n,i)*Number(s[s.length-i-1])
     }
   }

   console.log(res)
  //  console.log(res)
  //  let l1 = n1.length
  //  let l2 = n2.length
  //  for(let i=0;i<n1.length;i++){
     
  //     res = Math.pow(2,i)*Number(n1[l1-i-1])+res
      
  //  }

  //  for(let j=0;j<n2.length;j++){
     
  //    res = Math.pow(2,j)*Number(n2[l2-j-1])+res
     
  // }
   

 
  
  }

add('01','10',10)

function call3(){
  console.log(...arguments)
}

call3(1,2,3)

// async function async1() {
//   await async2()
//   console.log('async1 end')
//   await async2()
//   console.log('async2 start')
// }
// async function async2() {
//   console.log('async2 end')
// }
// async1()
// 顺序：
// async2 end；
// async2 end 
// async1 end
// async2 start 

//async
//async2 end
//async1 end
//async2 end
//async2 start 
function quicksort(arr){
   if(arr.length<=1){
     return arr
   }
   let midpivot = arr.length/2
   let mid = arr.splice(midpivot,1)[0]
   let left = []
   let right = []
   for(let i =0;i<arr.length;i++){
    if(arr[i]<mid){
           left.push(arr[i])
        }else{
           right.push(arr[i])
        }
   }
   return quicksort(left).concat(mid,quicksort(right))
}



let set1  = function(arr){
   let map = []
   map.push(arr[0])
   for(i=1;i<arr.length;i++){
     if(map.indexOf(arr[i])==-1){
        map.push(arr[i])
        
     }
   }
   return map
   
}

console.log(set1([2,4,4,4,5]))



</script>